doctype html
html
  head
    title Finance
    meta(name='viewport', content='user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0')
    meta(name='mobile-web-app-capable', content='yes')
    meta(name='apple-mobile-web-app-capable', content='yes')
    
    style
      :stylus
        .flex-container
          display flex
          flex-flow row wrap
      
        form
          &:valid fieldset
            border-color lime
            
          label
            margin 3px 0
            
            display block
            text-align right
            
            input
              width 70%
              margin-left 5px
              
          button
            display block
            margin-left auto
        
        #dbdump
          
          .del
            color red
            font-weight bold
            cursor pointer
            &::before
              content " X"
  body
    script(src='pouchdb/pouchdb.min.js')
    script(src='jquery/jquery.min.js')
    script(src='underscore/underscore.js')
    script(src='mercury/mercury.js')
    
    script
      :livescript
        {h} = hg = mercury
        log = console~log
        local-db = new PouchDB \finance
        
        # adapters
        
        db-array = (opts = {}) ->
          # TODO: avoid mutating opts?
          # TODO: use custom observable to remove change query
          # - also possibly consolidate to one change feed and subscribe (borrow a pubsub impl. from somewhere?)
          arr = hg.array []
          
          if opts.startkey? and not opts.endkey?
            c = (opts.startkey.slice -1 .charCodeAt 0) + 1 |> String.fromCharCode
            opts.endkey = (opts.startkey.slice 0 -1) + c
            opts.inclusive_end = false
          
          # TODO: do we use struct or value?
          init-query = opts with { +include_docs }
          local-db.allDocs init-query
          .catch log
          .then (res) !->
            arr.set res.rows.map -> hg.value it.doc
          
          if opts.startkey?
            # TODO: account for +inclusive_end
            opts.filter = -> opts.startkey <= it._id < opts.endkey
          
          change-query = opts with { +live, +include_docs, since: \now }
          
          local-db.changes change-query
          .on \change (c) !->
            var ind
            arr.some (d, i) ->
              if d!_id == c.id
                ind := i
            if c.deleted
              arr.splice ind, 1
            else if ind?
              arr.put ind, hg.value c.doc
            else
              # insert in order?
              arr.push hg.value c.doc
          
          arr
        
        # TODO: array varient
        db-query = (view, opts = {}) ->
          hash = hg.varhash {}, hg.value
          
          if opts.startkey? and not opts.endkey?
            # could better be written recursively...
            gen-end-key = ->
              c = (it.slice -1 .charCodeAt 0) + 1 |> String.fromCharCode
              (it.slice 0 -1) + c
            if typeof! opts.startkey is \Array
              opts.endkey = [gen-end-key opts.startkey[0]]
            else
              opts.endkey = gen-end-key opts.startkey
            opts.inclusive_end = false
          
          view-query = opts with { +include_docs }
          local-db.query view, view-query
          .catch log
          .then (res) !->
            for r in res.rows
              hash.put r.key, r.doc
          
          change-query = opts with { +live, +include_docs, since: \now, filter: \_view, view }
          
          local-db.changes change-query
          .on \change (c) !->
            local-db.query view, view-query
            .catch log
            .then (res) !->
              old = hash!
              oldkeys = Object.keys old
              n = _.index-by res.rows, (.key)
              newkeys = Object.keys n
              for k in _.difference newkeys, oldkeys
                hash.put k, n[k].doc
              for k in _.difference oldkeys, newkeys
                hash.delete k
              for k in _.intersection oldkeys, newkeys
                if old[k]._rev != n[k].doc._rev
                  hash.put k, n[k].doc
          
          hash
        
        # queries
        
        # TODO: create a setup in app lifecycle?
        create-index = (name, map, reduce) ->
          local-db.put {
            _id: "_design/#name"
            views:
              "#name":
                map: map.toString!
                reduce: reduce?.toString!
          } .catch !-> log it unless it.status == 409
        
        index-promises = [
          create-index 'accts' !->
            emit it.name if 'acct-' <= it._id < 'acct.'
          create-index 'ledger' !->
            return unless 'xact-' <= it._id < 'xact.'
            post-date = +(it._id.slice 5)
            for x in it.offsets
              emit [x.acct, post-date]
        ]
        
        <- Promise.all index-promises .then
        
        accts = db-query \accts
        ledger = db-query \ledger {
          startkey: ['acct-49496']
          # TODO: reduction for running total; probably do a custom one client-side
        }
        
        # channels
        
        epoch = +new Date 2015 8 12 0 0 0
        gen-id = -> Math.floor (Date.now! - epoch) / 1000
        
        channels =
          acct-add: (s, d) ->
            local-db.put {
              d._id ? "acct-#{gen-id!}"
              d._rev
              d.name
            }
            
          xact-add: (s, d) ->
            postDate = createDate = Date.now!
            local-db.put {
              _id: "xact-#postDate"
              createDate
              status: \verified
              offsets:
                * acct: (accts![d.from]._id)
                  sub: 100 * d.amt
                * acct: (accts![d.to]._id)
                  add: 100 * d.amt
            }
            
          doc-del: (s, d) ->
            local-db.remove d .catch log
            # optimistically update local state?
        
        window.app-state = app-state = hg.state {
          dump-state: db-array startkey: \a, endkey: \~
          accts
          ledger
          channels
        }
        
        # rendering
        
        lbl = (n, c, a) -> h \label [n, (h c, a)]
        
        var forms
        hg.app(
          $ \body .0
          app-state,
          (s) ->
            chs = s.channels
            # TODO: hg.partial
            forms ?:= [
            * h \form {
                \ev-submit : hg.sendSubmit chs.acct-add
              }, h \fieldset [
                h \legend 'Create Account'
                lbl 'Name' \input { name: \name, +required }
                h \button 'Create'
              ]
            * h \form {
                \ev-submit : hg.sendSubmit chs.xact-add
              }, h \fieldset [
                h \legend 'Create transaction'
                lbl 'From' \input { name: \from, +required, attributes: list: 'accts' }
                lbl 'To' \input { name: \to, +required, attributes: list: 'accts' }
                lbl 'Amount' \input { name: \amt, type: \number, step: 0.01, +required }
                h \button 'Create'
              ]
            ]
            
            h \div [
            * h \.flex-container [
              * forms
              * h \form [
                  h \datalist#accts (Object.keys s.accts .map ->
                    h \option value: it
                  )
                ]
              ]
            * h \.flex-container [
              * h \pre#dbdump (s.dump-state.map ->
                  h \div [
                    (JSON.stringify it, null 2),
                    h \span.del 'ev-click': hg.send chs.doc-del, it
                  ])
              * h \pre (JSON.stringify s.ledger, null 2)
              ]
            ]
        )
        